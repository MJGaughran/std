autoSaveRestore  --  save_restore.c v3.3; dbrestore.c v3.3

This software automatically saves the values of EPICS process variables
(PVs), to files on a server, and can automatically restore those values
when the VME crate is rebooted.  The original author is Bob Dalesio; I
made some improvements; Frank Lenkszus made some more improvements,
which I folded into the version I've been maintaining.  A bunch of
people contributed to getting the software running on PPC hardware,
including Ron Sluiter, Andrew Johnson, and Pete Jemian (APS), Markus
Janousch and David Maden (SLS), and I'm not sure who else.

autoSaveRestore is a collection of files, and a rather ungainly name.
In  this documentation, I'll use 'autosave' for short.  'save_restore'
is one part of autosave; it is the task that actually does the parameter
saving.  'reboot_restore' is the name of the function that restores
parameter values during reboot.

In versions earlier than 3.0, autosave's job was simply to save
parameters through a reboot.  The file server to which save files were
written was assumed competent to protect those files, and when the
server said a save file was safe, autosave believed it.  Beginning with
3.0, the file server is viewed as the enemy: autosave expects it to lie
about file status, to suddenly stop recognizing previously valid file
handles, and to return error codes that don't make sense.  Autosave
can now defend its NFS mount against a server reboot, defend parameter
values against a server power failure, and attempts to defend against a
user messing around with the directory into which save files are being
written.

Autosave now allows you to change, at run time, the directory and/or
the server to which save files are written.  Here's an example:

	# The normal autosave directory setup, in st.cmd: 
	save_restoreSet_NFSHost("oxygen", "164.54.52.4")
	set_savefile_path(startup, "autosave")
	...
	iocBoot()
	...
	(end of st.cmd)
	...
	# Type the following into the ioc's console
	save_restoreSet_NFSHost("wheaties", "164.54.53.101")
	# You'll get an immediate error if the old save file path doesn't
	# exist, or has adverse permissions, on the new server.
	set_savefile_path("/local/autosave", "")
	# autosave will immediately attempt to mount the new file path

The above code assumes the ioc has permission to mount file systems on
wheaties, and that the ioc has read/write/execute permission to
/local/autosave.

Autosave cannot defend against adverse file permissions, or against
the save directory (NFS mount point) disappearing altogether.


Contents
========

save_restore.c         -- saves PV values in files on a file server (or
                          whatever lame piece of crap happens to be lying
                          around) according to preset rules.
dbrestore.c            -- restore PV values at boot time, using dbStaticLib
initHooks.c            -- call restore routines at the correct time during boot.
fGetDateStr.c          -- Frank Lenkszus' date-string routines
save_restore.h         -- header
fGetDateStr.h          -- header
auto_settings.req      -- Sample request files
auto_positions.req 
reqInclude.tar         -- collection of autosave-request files with
                          parameterized PV names (e.g.,  "$(P)$(T).PREC")
                          intended  to be included in auto_settings.req.
                          This collection was copied from *App/Db directories
                          in the synApps_4.4 CVS repository on 8/27/03.
save_restoreStatus.adl -- MEDM display of autosave status.  Note that this
                          display assumes the files auto_positions.req and
                          auto_settings.req are used.
save_restoreStatus.db  -- database containing records autosave uses to report
                          status.  Note that this database assumes the files
                          auto_positions.req and auto_settings.req are used.

Differences from previous versions
==================================

save_restore v3.3; dbrestore v3.3:
----------------------------------
Several variables and user-callable functions have been renamed, as
their meanings have changed.  In preparation for 3.14, most
user-settable variables can now be set by a function call.

Autosave now maintains status PV's for each PV list, and rolled-up
status PV's for overall save status and reboot status.

fdblist() renamed as save_restoreShow(), now enhanced with more status
information, including rolled-up reboot status.

Can now maintain up to ten "sequence files" (named *.savX, where X is a
digit in [0..(save_restoreNumSeqFiles-1)]), which are copies of the
most recent .sav or .savB file, copied at user-specified intervals.  If
no valid .sav or .savB file exists, autosave will write sequence files
directly from its PV list, as though it were writing a .sav file.  At
boot time, if .sav and .savB are both corrupt or missing, autosave will
restore from the most recent sequence file.

No longer test fopen() by writing a temporary file, before saving.

save_restore will manage its own NFS mount, if the host name and
address has been specified with a call to save_restoreSet_NFSHost(),
and the save_restore file path (used as the mount point) has been set
by a call to set_savefile_path().  When more than ten unexpected I/O
errors have occurred, autosave will attempt to remount the file system.

Previously, save_restore saved floats and doubles using an algorithm
that was prone to failure, especially for PV's from another ioc.
(Thanks to Mark Rivers)

Now use errlogPrintf() for all messages except those from callback
routines, where logMsg() is used.

All CA monitors are now set up by the save_restore task.  Previously,
some were setup by whatever task called create_XXX_set().

Previously, if a save-file write failed, it would not be retried until
the normal conditions (e.g., a PV's value changed) were again met.
Now, if enough I/O errors have accumulated to cause an NFS remount, all
save sets in failure are written immediately after the remount succeeds.

Some ca_pend timeouts adjusted or limited.

Save files now contain the time at which they were written, in the
format of fGetDateStr() -- yy/mm/dd-hh/mm/ss.

Dated backup files now have an underscore between the name and the
date.

Previously, if the second fopen() call in myFileCopy() failed, the
function would return without closing the first file.

Previously, autosave would overwrite corrupted files in the normal
course of operation.  Now, whenever a corrupted file is encountered, a
copy is made.  If the copy is made at restore time, the copy is named,
e.g., auto_settings.sav_RBAD_030818-134850; if at save time, it's
named, e.g., auto_settings.sav_SBAD_030818-134850

save_restore no longer uses the vxWorks 'copy' command for anything,
because it writes files with inconvenient permissions.

save_restore v2.9a; dbrestore v2.7:
----------------------------------
Previously, create_data_set() would return without releasing a
semaphore (causing the save_restore task to hang) if called with
save_method==TRIGGERED, but no trigger channel was specified.

Previously, fdbrestore() would return without releasing a semaphore
(causing the save_restore task to hang) if called with the name of a
save set currently being maintained, and the save list contained
unconnected PV's, and the variable 'sr_restore_incomplete_sets_ok' was
false.

Added macro-string argument to create_xxx_set()

Added argument 'verbose' to fdblist()

Added second argument, 'subpath', to set_XXXfile_path(). This allows
the caller to pass the path as two args to be concatenated, making it
easier to build the path string using a variable set in the cdCommands
file.

Use logMsg() instead of epicsPrintf() for several informational
messages.

The variables chlist and reqFilePathList are now private.

Increased ca_pend_io search timeout in connect_list() from 2 to 5
seconds.  Decreased fetch timeout from num_channels/10 to 10 seconds.

Decreased ca_pend_io clear-channel timeout from num_channels/10 to 10
seconds in remove_data_set().

Changed call to macParseDefns() to specify the macro-substitution
handle.

save_restore v2.7; dbrestore v2.7:
---------------------------------

        ***********************************************************
        ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION 
        ***********************************************************
This version is incompatible in one important respect with versions of
save_restore.c numbered lower than 2.6:  The functions
	create_periodic_set()
	create_monitor_set()
	reload_periodic_set()
	reload_monitor_set()
now take 'int' arguments to specify time periods, instead of 'double'
arguments.  This change was required for compatibility with PPC
processors.

In Frank Lenkszus' version, the calls 
	set_pass<n>_restoreFile()
were required to specify files to be restored.  In this version, if no
restore files have been specified, initHooks specifies the default files
auto_positions.sav and auto_settings.sav for you, for backward
compatibility with my previous version.  If you really don't want to
restore any files, you now must either not load initHooks, or replace
it with your own version.

In Frank Lenkszus' version, set_requestfile_path() could specify only a
single directory.  Now that include files are a possibility, you can
specify several request-file directories by calling
set_requestfile_path() several times.

Backup files made as part of a restore operation (i.e., files ending in
".bu", or "YYMMDD-HHMMSS") are no longer created using the VxWorks
"copy" command.


How to use this software
========================

This software can be used in many different ways.  I'll describe what
you have to do to use it as it's commonly used at APS beamlines to save
PV values periodically, and restore them on reboot.


*) (required) Build save_restore.o, dbrestore.o, initHooks.o, and
fGetDateStr.o.  Don't use an old copy of initHooks.o.  Although
initHooks.c hasn't changed since save_restore v2.6, it uses a data
structure from save_restore.h, which has changed.


*) (required) Create "request" files (e.g., auto_settings.req,
auto_positions.req) specifying the PVs whose values you want to save
and restore.  The save files corresponding to these request files will
have the ".req" suffix replaced by ".sav".

Request files can include other request files (nested includes are
allowed) and macro substitution can be performed on the included files
(using William Lupton's macro library), with the following syntax:

	file <request_file> <macro-substitution_string>

e.g.,

	file xx_auto_motor_settings.req P=xxx:,M=m1

I've tried to defend against forseeable variations in syntax, so that
include lines with embedded whitespace and/or quotes, macro strings
without commas, empty macro strings, and lines with trailing comments
will be parsed as one would want.  Generally, quotes are ignored,
whitespace implies a comma but otherwise is ignored, and everything
after the second sequence of non-whitespace characters (i.e., after the
file name) and before the (optional) comment character '#' is taken as
the macro-substitution string.  Macro substitution is performed on the
entire line, so it's possible to parameterize names of included files,
as well as PV names.  It is also possible to define a macro that
replaces its target with nothing.


*) (optional, recommended) Specify one or more directories to be
searched for request files using one or more invocations of the
function

	set_requestfile_path()


*) (optional, recommended) Specify the NFS host from which save files
will be read, at restore time, and to which they will be written, at
save time, by calling the function

	save_restoreSet_NFSHost()


*) (strongly recommended) Use NFS, preferably as described above, or by
including an nfsMount() command in your startup script.  Autosave is only
tested with NFS, though it has in the past and may still work with vxWorks'
netDrv (ftp or rsh).


*) (optional, recommended) Specify the directory in which you want save
files to be written, by calling the function

	set_savefile_path()

in your startup script, before the create_xxx_set() commands, to
specify the path to the directory.  If you are using NFS (strongly
recommended), ensure that the path does not contain symbolic links.  In
my experience, VxWorks cannot write through a symbolic link.  (I don't
understand all the ins and outs of this limitation.)


*) (required) Give the "crate" write permission to the directory in
which the save files are to be written.  If you forget this step,
autosave may be able to write save files, but the files will be
corrupted because the crate will not be able to change their lengths.
autosave attempts to detect this condition, but cannot work
around it if the file length must increase.


*) (optional, recommended) Specify which save files are to be restored
before record initialization (pass 0) and which are to be restored
after record initialization (pass 1), using the commands

	set_pass0_restoreFile()
	set_pass1_restoreFile()

Place these commands in the startup file before iocInit.  If you don't
call either of these functions (or if your calls fail completely to
specify any restore files) the supplied initHooks routine will attempt
to restore the file "auto_positions.sav" before record init, and the
file "auto_settings.sav" both before and after record init.

Notes:
  Link fields cannot be restored (by dbStatic calls) after record
  initialization.  If you want save/restore to work for link fields you
  must specify them in a pass-0 file.  It is not an error to specify link
  fields in a pass-1 file, but this software will not try to restore them.

  Device support code for the motor record uses the value of the field
  DVAL, restored during pass 0, only if the value read from the hardware
  is zero.  If the value from hardware is nonzero, it is used instead of
  the restored value.


*) (required) Load a copy of initHooks that calls reboot_restore() to
restore saved parameter values.  The copy of initHooks included in
this distribution is recommended.


*) (optional, recommended) Tell autosave to writed dated backup files.
At boot time, the restore software writes a backup copy of the ".sav"
file from which it restored PV's.  This file can either be named
xxx.sav.bu, and be rewritten every reboot, or named xxx.sav_YYMMDD-HHMMSS,
where "YY..." is a date.  Dated backups are not overwritten.  If you want
dated backup files (recommended), put either of the following two lines
to your st.cmd file before the call to iocInit():

	save_restoreDatedBackupFiles=1
OR
	save_restoreSet_DatedBackupFiles(1)


Note:
  If a save file is restored in both pass 0 and pass 1, the boot-backup
  file will be written only during pass 0.


*) (required) Invoke the "save" part of this software as part of the
EPICS startup sequence, by adding lines of the form

	create_monitor_set("auto_positions.req", 5, "P=xxx:")
	create_monitor_set("auto_settings.req", 30, "P=xxx:")

to the end of your EPICS startup file.  You can call the files anything
you want.  The third argument is a macro-substitution string, as
described above in the discussion of request files.  If supplied, this
macro-substitution string supplements any macro strings supplied in
include-file directives of request files read for this save set.

For each "create_monitor_set(<name>.req, <time>, <macro>)" command, the
save_restore process will write the files <name>.sav and <name>.savB
every <time> seconds, if any of the PVs named in the file <name>.req
have changed value since the last write.  Other create_xxx_set()
commands do the same thing, but with different conditions triggering
the save operation.

Note that in versions prior to 2.7, create_monitor_set() used an
argument of type double to specify the period (in seconds).  This
doesn't work on the PPC, so the arguments for this and similar
functions were changed to int.

If your VME crate takes a really long time to boot, it's possible the
PVs you want to save will not have the correct values when the
save_restore task first looks at them.  You can avoid this by putting a

	taskDelay(<number_of_60_Hz_clock_ticks>)

before create_monitor_set().



About save files
================
Save files are not intended to be edited manually.  If you,
nevertheless, do edit a save file, you must end it with the text

<END>

followed by a single arbitrary character (normally '\n').  If the file
does not end with this text, reboot_restore() will assume the crate
crashed while the file was being written, and will not use the file.
Once a save file has been created successfully, save_restore will not
overwrite the file unless a good ".savB" backup file exists.
Similarly, it will not overwrite the ".savB" file unless the save file
was successfully written.



User-callable functions:
========================

int manual_save(char *request_file);
	If a manual save set for the request file "request_file" was created
	with create_manual_set(), this command will cause current PV values to
	be saved.

int set_savefile_name(char *request_file, char *save_file);
	If a save set has already been created for the request file, this
	function will change the save file name.

int create_periodic_set(char *request_file, int period, char *macrostring);
	Create a save set for the request file.  The save file will be written
	every <period> seconds.
	This function can be called at any time after iocInit.

int create_triggered_set(char *request_file, char *trigger_channel,
		char *macrostring);
	Create a save set for the request file.  The save file will be written
	whenever the PV specified by <trigger_channel> is posted.  Normally
	this occurs when the PV's value changes.
	This function can be called at any time after iocInit.

int create_monitor_set(char *request_file, int period, char *macrostring);
	Create a save set for the request file.  The save file will be written
	every <period> seconds, if any PV in the save set was posted (changed
	value) since the last write.
	This function can be called at any time after iocInit.

int create_manual_set(char *request_file, char *macrostring);
	Create a save set for the request file.  The save file will be written
	when the function manual_save() is called with the same request-file
	name.
	This function can be called at any time after iocInit.

int fdbrestore(char *save_file);
	If <save_file> refers to a save set that exists in memory, then PV's
	in the save set will be restored from values in memory.  Otherwise, this
	functions restores the PV's in <saveRestorePath>/<save_file> and creates
	a new backup file "<saveRestorePath>/<save_file>.bu".  The effect
	probably will not be the same as a boot-time restore, because caput()
	calls are used instead of static database access dbPutX() calls.
	Record processing will result from caput()'s to inherently process-
	passive fields.
	This function can be called at any time after iocInit.

int fdbrestoreX(char *save_file);
	This function restores from the file <saveRestorePath>/<save_file>, which
	can look just like a save file, but which needn't end in <END>.  No backup
	file will be written.  The effect probably will not be the same as a
	boot-time restore, because caput() calls are used instead of static
	database access dbPutX() calls.  Record processing will result from
	caput()'s to inherently process-passive fields.
	This function can be called at any time after iocInit.

void save_restoreShow(int verbose);
	List all the save sets currently being managed by the save_restore task.
	If (verbose != 0), lists the PV's as well.
	This function can be called at any time after iocInit.

int set_requestfile_path(char *path, char *pathsub);
	Called before create_xxx_set(), this function specifies the path to be
	prepended to request-file names.  <pathsub>, if present, will be appended
	to <path>, if present, with a separating '/' whether or not <path> ends
	or <pathsub> begins with '/'.  If the result does not end in '/', one will
	be appended to it.
	You can specify several directories to be searched for request files by
	calling this routine several times.  Directories will be searched in the
	order in which the set_requestfile_path() calls were made.  If you never
	call the routine, the crate's current working directory will be searched.
	If you ever call it, the current directory ("./") will be searched only if
	you've asked for it explicitly.

int set_savefile_path(char *path, char *pathsub);
	Called before iocInit(), this function specifies the path to be prepended
	to save-file and restore-file names.   <pathsub>, if present, will be
	appended to <path>, if present, with a separating '/' whether or not <path>
	ends or <pathsub> begins with '/'.  If the result does not end in '/', one
	will be appended to it.
	If save_restore is managing its own NFS mount, this function specifies the
	mount point, and calling it will result in an NFS mount if all other
	requirements have already been met.  If a valid NFS mount already exists,
	the file system will be dismounted and then mounted with the new path name.
	This function can be called at any time.

int set_saveTask_priority(int priority);
	Set the priority of the save_restore task.

int remove_data_set(char *request_file);
	If a save set has been created for <request_file>, this function will
	delete it.

int reload_periodic_set(char *request_file, int period, char *macrostring);
	This function allows you to change the PV's and the period associated with
	a save set created by create_periodic_set().

int reload_triggered_set(char *request_file, char *trigger_channel,
		char *macrostring);
	This function allows you to change the PV's and the trigger channel
	associated with a save set created by create_triggered_set().

int reload_monitor_set(char * request_file, int period, char *macrostring);
	This function allows you to change the PV's and the period associated with
	a save set created by create_monitor_set().

int reload_manual_set(char * request_file, char *macrostring);
	This function allows you to change the PV's associated with a save set
	created by create_manual_set().

    Note: Don't get too ambitions with the remove/reload functions.  You
    have to wait for one to finish completely (the save_restore task must
    get through its service loop) before executing another.  If you call
    one before the previous function is completely finished, I don't know
    what will happen.

int reboot_restore(char *save_file, initHookState init_state)
	This should only be called from initHooks because it can only function
	correctly if called at particular times during iocInit.

int set_pass0_restoreFile(char *save_file)
	This function specifies a save file to be restored during iocInit,
	before record initialization.
	Up to eight files can be specified using calls to this function.

int set_pass1_restoreFile(char *save_file)
	This function specifies a save file to be restored during iocInit,
	after record initialization.
	Up to eight files can be specified using calls to this function.

void save_restoreSet_Debug(int debug_level)
	Sets the value (int) save_restoreDebug.
	Initially 0.  Increase to get more informational messages printed
	to the console.
	This function can be called at any time.

void save_restoreSet_IncompleteSetsOk(int ok)
	Sets the value of (int) save_restoreIncompleteSetsOk
	Initially 1.  If set to zero, save files will not be restored at boot
	time unless they are perfect, and they will not be overwritten at save
	time unless a valid CA connection exists for every PV in the list.
	This function can be called at any time.

void save_restoreSet_NumSeqFiles(int numSeqFiles)
	Sets the value of (int) save_restoreNumSeqFiles.
	This is the number of sequenced backup files to be maintained.  
	This function can be called at any time.

void save_restoreSet_SeqPeriodInSeconds(int period)
	Sets the value of (int) save_restoreSeqPeriodInSeconds.
	Sequenced backup files will be written with this period.
	This function can be called at any time.

void save_restoreSet_DatedBackupFiles(int ok)
	Sets the value of (int) save_restoreDatedBackupFiles
	If zero, the backup file written at reboot time (a copy of the file
	from which parameter values are restored) will have the suffix '.bu',
	and will be overwritten every reboot.  If nonzero, each reboot will
	leave behind its own backup file.
	This function can be called at any time.

void save_restoreSet_status_prefix(char *prefix)
	Specifies the prefix to be used to construct the names of PV's with
	which save_restore reports its status.
	This function must be called before the first call to create_xxx_set().

void save_restoreSet_NFSHost(char *hostname, char *address)
	Specifies the name and IP adress of the NFS host.  If both have been
	specified, and set_savefile_path() has been called to specify the file
	path, autosave will manage its own NFS mount.  This allows autosave to
	recover from a reboot of the NFS host (i.e., a stale file handle) and
	from from some kinds of tampering with the autosave directory.


Example of use:
===============

---------- begin excerpt from st.cmd ----------------------

### Load custom EPICS software [including save_restore.o and dbrestore.o]
ld < xxxLib
.
.
.
### autoSaveRestore setup
save_restoreSet_Debug(0)

# status-PV prefix, so save_restore can find its status PV's.
save_restoreSet_status_prefix("xxx:")

# ok to restore a save set that had missing values (no CA connection to PV)?
# ok to save a file if some CA connections are bad?
save_restoreSet_IncompleteSetsOk(1)

# In the restore operation, a copy of the save file will be written.  The
# file name can look like "auto_settings.sav.bu", and be overwritten every
# reboot, or it can look like "auto_settings.sav_020306-083522" (this is what
# is meant by a dated backup file) and every reboot will write a new copy.
save_restoreSet_DatedBackupFiles(1)

# specify where save files should go
set_savefile_path(startup, "autosave");

## specify where request files can be found
# current directory
set_requestfile_path(startup, "")
# We want to include request files that are stored with the databases they
# support -- e.g., in stdApp/Db, mcaApp/Db, etc.  The variables std and mca
# are defined in cdCommands.  The path is searched in the order in which
# directories are specified. 
set_requestfile_path(startup)
set_requestfile_path(std, "stdApp/Db")
set_requestfile_path(motor, "motorApp/Db")
set_requestfile_path(mca, "mcaApp/Db")
set_requestfile_path(ip, "ipApp/Db")
set_requestfile_path(ip330, "ip330App/Db")
# [...]

# specify what save files should be restored when
# up to eight files can be specified for each pass
set_pass0_restoreFile("auto_positions.sav")
set_pass0_restoreFile("auto_settings.sav")
set_pass1_restoreFile("auto_settings.sav")
# [...]

# Number of sequenced backup files (e.g., 'auto_settings.sav0') to write
save_restoreSet_NumSeqFiles(3)

# Time interval between sequenced backups
save_restoreSet_SeqPeriodInSeconds(60)

# NFS host name and IP address
save_restoreSet_NFSHost("oxygen", "164.54.52.4")

# Currently, the only thing we do in initHooks is call reboot_restore(), which
# restores positions and settings saved ~continuously while EPICS is alive.
# See calls to "create_monitor_set()" at the end of this file.  To disable
# autorestore, comment out the following line.
ld < initHooks.o
.
.
.
dbLoadDatabase("../../dbd/xxxApp.dbd")
dbLoadRecords("xxxApp/Db/whatever.db"...

dbLoadRecords("stdApp/Db/save_restoreStatus.db","P=xxx:", std)
.
.
.
iocInit
.
.
.
### Start up the autosave task and tell it what to do.
# The task is actually named "save_restore".
# (See also, 'initHooks' above, which is the means by which the values that
# will be saved by the task we're starting here are going to be restored.
#
# save positions every five seconds
create_monitor_set("auto_positions.req", 5, "P=xxx:")
# save other things every thirty seconds
create_monitor_set("auto_settings.req", 30, "P=xxx:")
.
.
.

---------- end excerpt from st.cmd ----------------------


Tim Mooney
8/27/03
